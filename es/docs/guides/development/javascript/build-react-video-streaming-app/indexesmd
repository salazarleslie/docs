---
slug: build-react-video-streaming-app
author:
  name: Linode Community
  email: docs@linode.com
description: 'Learn how to build a video streaming application with two components: a server-side Node.js application that will stream videos and generate video thumbnails, and a client application in React that will list and play the videos.'
og_description: 'Learn how to build a video streaming application with two components: a server-side Node.js application that will stream videos and generate video thumbnails, and a client application in React that will list and play the videos.'
keywords:
  - 'React'
  - 'Nodejs'
  - 'Video streaming'
  - "video captions"
  - "video thumbnails"
license: '[CC BY-ND 4.0](https://creativecommons.org/licenses/by-nd/4.0)'
published: 2020-08-09
modified_by:
  name: Linode
title: "How to Build a Video Streaming Application with React and Node"
h1_title: "Building a Video Streaming Application with React and Node"
image: feature.png
contributor:
  name: Deven Rathore
  link: https://codesource.io/
external_resources:
  - '[Video Stream With Node.js and HTML5](https://medium.com/better-programming/video-stream-with-node-js-and-html5-320b3191a6b6)'
  - '[Adding captions and subtitles to HTML5 video](https://developer.mozilla.org/en-US/docs/Web/Guide/Audio_and_video_delivery/Adding_captions_and_subtitles_to_HTML5_video)'
tags:
  - "web applications"
aliases:
  - '/development/javascript/build-react-video-streaming-app/'
---

## Introduction

Building a video streaming application might seem daunting at first, but this guide will breakdown how this can be achieved. Specifically, we'll demonstrate how to implement a streaming service with the following components:

- A server-side *Node.js* application that will handle fetching and streaming videos, generating thumbnails for your videos, and serving captions and subtitles for videos.
- A client application in *React* that will consume the videos on our server. This application will have two views: a listing of videos that are available, and a player view for each video.

When completed, your application will look as follows:

![React Video streaming app](Image7.png "React Video streaming app final preview 1")

![React Video streaming app](Image8.png "React Video streaming app final preview 2")

### About Video Streams

Videos work with streams. This means that instead of sending the whole video at once, a video is sent as a set of smaller chunks which make up the full video. This explains why if you are on a slow broadband and watching a video, it buffers because it plays the chunk it has received and tries to load more.

## Before You Begin

For this tutorial, you’ll need:

- A basic understanding of HTML, CSS, JavaScript, Node/Express, and React
- A text editor (e.g. VS Code or Atom)
- A web browser (e.g. Chrome, Firefox)
- [FFmpeg](https://www.ffmpeg.org/download.html) installed on your workstation
- [Node.js](https://nodejs.org/en/download/). [Node Version Manager (nvm)](https://github.com/nvm-sh/nvm) can be used to install and maintain several versions of Node on your computer.

{{< note >}}
When following the tutorial, you can refer to the [project source code](https://github.com/Dunebook/Videostreaming-app) to compare your code with the final result.
{{< /note >}}

## Application Setup

For the purposes of this tutorial, both the server application and the client application will be built on your workstation. To get started, create a new directory that will contain both components of your application. You can do this from the terminal or a GUI interface:

    mkdir react-node-video-streaming

### Setting Up the Server

1. We'll build the *server* with Node.js. Inside our project directory, create a folder called `server`:
   
        cd react-node-video-streaming
        mkdir server

1. Next, let's setup the server:
   
        cd server
        npm init

1. Follow the prompts from `npm init` and use the default values it suggests. When the command finishes, it creates a `package.json` file in the directory.

1. Install the packages the server will need:
   
        npm install --save nodemon express cors

    - `nodemon` automatically restarts our server when we make changes.

    - `express` gives us a nice interface to handle routes.

    - `cors` will allow us to make cross-origin requests since our client and server will be running on different ports.

1. Inside the `server` project, create a folder called `assets`. This will hold the video files for the server application:
   
        mkdir assets

1. Copy a `.mp4` video file into the new `assets` folder, and make sure it is named `sample.mp4`. For example, you can download one of the videos from the guide's [project source repository](https://github.com/Dunebook/Videostreaming-app/tree/master/server/assets) and rename it to `sample.mp4`.

1. We can start writing code for our server. Create a new file in the root of the `server` directory called `app.js` and add the following snippet:

    {{< file "server/app.js" js >}}
const express = require('express'); const fs = require('fs'); const path = require('path');

const app = express();
{{< /file >}}

    This just imports the packages we'll be using. The `fs` module makes it easy to read and write to files on the server.

1. For now, we'll create a single `/video` route. When requested, it will send a video file back to the client. Add this line after the `const app` declaration in `server/app.js`:

    {{< file "server/app.js" js >}}
// add after 'const app = express();'

app.get('/video', (req, res) => { res.sendFile('assets/sample.mp4', { root: __dirname }); });
{{< /file >}}

    This routes simply serves the `sample.mp4` video file when requested.

1. Add this call to `app.listen()` to the end of `server/app.js`:

    {{< file "server/app.js" js >}}
// add to end of file

app.listen(4000, () => { console.log('Listening on port 4000!') });
{{< /file >}}

    This code sets up the server to listen on port 4000.

1. At the moment, the server is not running. In `package.json`, add the following `dev` script to the `scripts` section:

    {{< file "server/package.json" js >}}
//... "scripts": { "dev": "nodemon app.js", // ... }, // ...
{{< / file >}}

1. Then from your terminal, run:
   
        npm run dev

    If you see the message `Listening on port 4000!` in the terminal, then the server is working correctly. Navigate to [http://localhost:4000/video](http://localhost:4000/video) in your browser and you should see the video playing.

### Scaffolding the Frontend with React

1. Open a second terminal and create a new `client` directory in your projects folder:
   
        cd react-node-video-streaming
        mkdir client && cd client

1. Initialize a React project here like so:
   
        npx create-react-app .

    This command generates our application shell and installs the packages required by React. The `.` argument means all this setup happens in the current directory (`client`).

    {{< note >}}
If you don't have `npx` on your workstation, it can be installed globally with:

    npm install -g npx
{{< /note >}}

1. Once it is done, open `src/App.js` in your `client` project and replace the contents with:

    {{< file "client/src/App.js" js >}} import React from 'react'; import './App.css'; function App() { return (
        <div className="App">
            <header className="App-header">
            <video controls muted>
                <source src="http://localhost:4000/video" type="video/mp4"></source>
            </video>
            </header>
        </div>
 ); } export default App;
{{< /file >}}

    In this markup, we have a single `video` element, and the `src` is the route on our server that serves the sample video file.

1. Save it, and in your terminal run:
   
        yarn start

    Or if you prefer to use `npm`, run:
   
        npm start

    This command starts a web server and opens the React application in your browser. You should see the video in your React application.

## Building Out the Frontend

So far, we've set up our server to serve a video file when requested. In reality, our React application will have two views:

- A **Home** view that will contain a list of videos
- A **Player** view where videos will play

We'll be using Bootstrap to layout our interface, so add the following to the `head` section of `public/index.html` in your `client` project:

{{< file "client/public/index.html" html >}}

{=lt=}!-- add to 

<head>
  --{=gt=} 
  
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.4.1/css/bootstrap.css" />
  </p> 
  
  <p spaces-before="0">
    {{< /file >}}
  </p>
  
  <p spaces-before="0">
    Our application will have two routes to handle the <code>Home</code> and <code>Player</code> views, so install <code>react-router-dom</code> to handle routing of the React application. From the terminal, run the command:
  </p>
  
  <ul>
    <li>
      <p spaces-before="0">
        If you are using yarn:
      </p>
      <pre><code>  yarn add react-router-dom
</code></pre>
    </li>
    <li>
      <p spaces-before="0">
        If you are using npm:
      </p>
      <pre><code>  npm install --save react-router-dom
</code></pre>
    </li>
  </ul>
  
  <p spaces-before="0">
    This installs the recommended router for React applications.
  </p>

<h3 spaces-before="0">
  Create the Home View
</h3>

<p spaces-before="0">
  We can start to build out the necessary views. Let’s start with the <code>Home</code> view. Create a new file <code>src/Home.js</code> in your <code>client</code> project and add the following snippet:
</p>

<p spaces-before="0">
  {{< file "client/src/Home.js" js >}} import React, { Component } from 'react'; import { Link } from 'react-router-dom'; export default class Home extends Component { constructor() { super(); this.state = { videos: [] }; } async componentDidMount() { try { const response = await fetch('http://localhost:4000/videos'); const data = await response.json(); this.setState({ videos: [...data] }); } catch (error) { console.log(error); } } render() { return (
            <div className="App App-header">
                <div className="container">
                    <div className="row">
                        {this.state.videos.map(video =>
                        <div className="col-md-4" key={video.id}>
                            <Link to={`/player/${video.id}`}>
                                <div className="card border-0">
                                    <img src={`http://localhost:4000${video.poster}`} alt={video.name} />
                                    <div className="card-body">
                                        <p>{video.name}</p>
                                        <p>{video.duration}</p>
                                    </div>
                                </div>
                            </Link>
                        </div>
                        )}
                    </div>
                </div>
            </div>
        ) } }
{{< /file >}}
</p>

<p spaces-before="0">
  Our component starts off by importing some required packages (lines 1-2). Then it initializes the state variable <code>videos</code> to an empty array (line 7). In the <code>componentDidMount</code> (lines 10-18), it makes a request to an endpoint (http://localhost:4000/videos), which will return an array of video metadata. This metadata will be represented as array of objects, where each object looks like:
</p>

<p spaces-before="0">
  {{< highlight js >}}
</p>

<p spaces-before="0">
  {
    id: 0,
    poster: '/video/0/poster',
    duration: '3 mins',
    name: 'Sample 1'
}
</p>

<p spaces-before="0">
  {{< / highlight >}}
</p>

<p spaces-before="0">
  After fetching the video metadata, we render it as a list of videos (lines 19-40). Each card is wrapped with a link to the Player view, which will be created in the next section.
</p>

<p spaces-before="0">
  On line 28, another endpoint request is made to <code>http://localhost:4000${video.poster}</code>, which will return a thumbnail of a video in the list. The <code>video.poster</code> variable is populated with a value like <code>/video/0/poster</code> from the video metadata array, so the request will have the form <code>http://localhost:4000/video/:id/poster</code>.
</p>

<p spaces-before="0">
  {{< note >}}
</p>

<p spaces-before="0">
  We have not created the <code>/videos</code> metadata endpoint, or the <code>/video/:id/poster</code> video thumbnail endpoint yet. These will be added to the <code>server</code> project in the <a href="#handling-requests-from-the-frontend">Handling Requests from the Frontend</a> section.
</p>

<p spaces-before="0">
  {{< /note >}}
</p>

<h3 spaces-before="0">
  Create the Player View
</h3>

<p spaces-before="0">
  Next, we create the player view. Create a new file <code>src/Player.js</code> in the <code>client</code> project and add the following snippet:
</p>

<p spaces-before="0">
  {{< file "client/src/Player.js" js >}} import React, { Component } from 'react' export default class Player extends Component { constructor(props) { super(props); this.state = { videoId: this.props.match.params.id, videoData: {} }; } async componentDidMount() { try { const res = await fetch(<code>http://localhost:4000/video/${this.state.videoId}/data</code>); const data = await res.json(); this.setState({ videoData: data }); } catch (error) { console.log(error); } } render() { return (
            <div className="App">
                <header className="App-header">
                    <video controls muted autoPlay>
                        <source src={`http://localhost:4000/video/${this.state.videoId}`} type="video/mp4"></source>
                    </video>
                    <h1>{ this.state.videoData.name }</h1>
                </header>
            </div>
        ) } }
{{< /file >}}
</p>

<p spaces-before="0">
  For the player view, we get the video <code>id</code> from the URL parameter (line 6):
</p>

<ul>
  <li>
    With the <code>id</code>, we can make a request to the server to fetch metadata about the video: <code>http://localhost:4000/video/${this.state.videoId}/data</code>, on line 12.
  </li>
  <li>
    In the markup for the view, the video element's <code>src</code> attribute is a link which appends the <code>id</code> to the <code>/video</code> route, and the server responds with the actual video: <code>http://localhost:4000/video/${this.state.videoId}</code>, on line 24.
  </li>
</ul>

<p spaces-before="0">
  {{< note >}}
</p>

<p spaces-before="0">
  We have not created the <code>/video/:id/data</code> metadata endpoint, or the <code>/video/:id</code> video streaming endpoint yet. These will be added to the <code>server</code> project in the <a href="#handling-requests-from-the-frontend">Handling Requests from the Frontend</a> section.
</p>

<p spaces-before="0">
  {{< /note >}}
</p>

<h3 spaces-before="0">
  Update App.js
</h3>

<p spaces-before="0">
  That's all we need for the views. Let's glue them both together. Replace the contents of your <code>src/App.js</code> with this snippet:
</p>

<p spaces-before="0">
  {{< file "client/src/App.js" js >}}
</p>

<p spaces-before="0">
  import React from 'react'; import { Route, BrowserRouter as Router, Switch, } from "react-router-dom"; import Home from './Home'; import Player from './Player'; import './App.css';
</p>

<p spaces-before="0">
  function App() { return ( <Router> <Switch> <Route exact path="/" component={Home}></Route> <Route path="/player/:id" component={Player}></Route> </Switch> </Router> ); } export default App;
{{< /file >}}
</p>

<p spaces-before="0">
  Here, we import the router package (lines 2-6), as well as our <code>Home</code> and <code>Player</code> view components (lines 7 and 8). The <code>/</code> route (line 15) shows the Home component. For the <code>/player</code> route (line 16), notice the dynamic <code>:id</code> which would match anything that matches the pattern. This is how we pass the <code>id</code> to the <code>Player</code> component.
</p>


<h2 spaces-before="0">
  Handling Requests from the Frontend
</h2>

<p spaces-before="0">
  Right now, we have four requests from the frontend that are not handled by our server yet:
</p>

<ul>
  <li>
    <code>/videos</code>: Returns an array of video metadata that will be used to populate the list of videos in the <code>Home</code> view
  </li>
  <li>
    <code>/video/:id/data</code>: Returns metadata for a single video. Used by the <code>Player</code> view.
  </li>
  <li>
    <code>/video/:id</code>: Streams a video with a given ID. Used by the <code>Player</code> view.
  </li>
  <li>
    <code>/video/:id/poster</code>: Returns a thumbnail for a video with a given ID. Used by the <code>Home</code> view.
  </li>
</ul>

<p spaces-before="0">
  Let's tackle them one after another:
</p>

<h3 spaces-before="0">
  Return Metadata for the List of Videos
</h3>

<p spaces-before="0">
  For this demo application, we'll create an array of objects that will hold the metadata and send that to the frontend when requested. In a real application, you would probably be reading the data from a database, which would then be used to generate an array like this. For simplicity's sake, we won’t be doing that in this tutorial.
</p>

<ol start="1">
  <li>
    <p spaces-before="0">
      From the <code>server</code> directory, open <code>app.js</code> and add this array declaration just after the <code>require()</code> statements:
    </p>
    <p spaces-before="4">
      {{< file "server/app.js" js >}}
    </p>
    <p spaces-before="0">
      // add after require() statements
    </p>
  </li>
</ol>

<p spaces-before="0">
  const videos = [
    { id: 0, poster: '/video/0/poster', duration: '3 mins', name: 'Sample 1' },
    { id: 1, poster: '/video/1/poster', duration: '4 mins', name: 'Sample 2' },
    { id: 2, poster: '/video/2/poster', duration: '2 mins', name: 'Sample 3' }, ];
</p>

<p spaces-before="0">
  {{< /file >}}
</p>

<pre><code>As you can see, each object contains information about the video. Notice the `poster` attribute which contains the link to a poster image of the video. Later in this tutorial, we’ll see how we can generate a poster image from a video.

With this in place, in `server/app.js`, let’s create a new route `/videos` that will send this data to the frontend.
</code></pre>

<ol start="1">
  <li>
    <p spaces-before="0">
      Add this line after the other <code>require()</code> statements at the top of the <code>server/app.js</code>:
    </p>
    <p spaces-before="4">
      {{< file "server/app.js" js >}}
    </p>
    <p spaces-before="0">
      // add after other require() statements
    </p>
  </li>
</ol>

<p spaces-before="0">
  const cors = require('cors');
</p>

<p spaces-before="0">
  {{< /file >}}
</p>

<ol start="1">
  <li>
    <p spaces-before="0">
      Add these lines just after the existing <code>app.get('/video', ...)</code> route:
    </p>
    <p spaces-before="4">
      {{< file "server/app.js" js >}}
    </p>
    <p spaces-before="0">
      // add after existing app.get('/video', ...) route
    </p>
  </li>
</ol>

<p spaces-before="0">
  app.use(cors()); app.get('/videos', (req, res) => res.json(videos));
</p>

<p spaces-before="0">
  {{< /file >}}
</p>

<pre><code>First, we enable `cors` on the server since we’ll be making the requests from a different origin (domain). `cors` was installed in the [Application Setup](#application-setup) section. Then the `/videos` route is declared, which returns the array we just created in `json` format.
</code></pre>

<ol start="1">
  <li>
    <p spaces-before="0">
      Save the file and it should automatically restart the server. Once it’s started, switch to your browser and check the React application. Your app should display the names and the duration of the videos, but not the thumbnails:
    </p>
    <p spaces-before="4">
      <img src="Image1.png" alt="React Video streaming app" title="React application" />
    </p>
  </li>
</ol>

<h3 spaces-before="0">
  Return Metadata for a Single Video
</h3>

<p spaces-before="0">
  Our React application fetches the video by <code>id</code>, so we can use the <code>id</code> to get the requested video metadata from the array. Let’s create a new route that will handle this in <code>server/app.js</code>. Add this snippet of code after the route from the previous section:
</p>

<p spaces-before="0">
  {{< file "server/app.js" js >}}
</p>

<p spaces-before="0">
  // add after app.get('/videos', ...) route
</p>

<p spaces-before="0">
  app.get('/video/:id/data', (req, res) => { const id = parseInt(req.params.id, 10); res.json(videos[id]); });
</p>

<p spaces-before="0">
  {{< /file >}}
</p>

<p spaces-before="0">
  If you remember, the <code>Player</code> view makes a request to <code>http://localhost:4000/video/${this.state.videoId}/data</code> which would match this route. This snippet gets the <code>id</code> from the route parameters and converts it to an integer. Then we send the object that matches the <code>id</code> from the <code>videos</code> array back to the client.
</p>

<p spaces-before="0">
  Now, the <code>Player</code> view should look like this:
</p>

<p spaces-before="0">
  <img src="Image2.png" alt="React Video streaming app" title="React application preview" />
</p>

<h3 spaces-before="0">
  Stream a Video
</h3>

<p spaces-before="0">
  In the <a href="#application-setup">Application Setup</a> section, we created a <code>/video</code> route that just serves a video to the client. This endpoint did not actually send smaller chunks of a video; instead, it just served an entire video file on request.
</p>

<p spaces-before="0">
  We now need to implement two new features that are not supported by that endpoint. First, we need to be able to dynamically serve one of the three videos that are in the <code>videos</code> array. Second, we need to stream the video in chunks.
</p>

<ol start="1">
  <li>
    <p spaces-before="0">
      Delete the <code>/video</code> route from <code>server/app.js</code>.
    </p>
  </li>
  
  <li>
    <p spaces-before="0">
      We need three videos, so copy the example videos from the tutorial's <a href="https://github.com/slightlynerd/react-node-video-streaming/tree/master/server/assets">source code</a> into the <code>assets/</code> directory of your <code>server</code> project. Make sure the filenames for the videos are <code>0.mp4</code>, <code>1.mp4</code>, and <code>2.mp4</code>, as these correspond to the <code>id</code>s in the <code>videos</code> array:
    </p>
    <p spaces-before="4">
      <img src="Image3.png" alt="React Video streaming app" title="Video Files preview" />
    </p>
  </li>
  
  <li>
    <p spaces-before="0">
      Create the route for streaming videos. Add this snippet below your other routes in <code>server/app.js</code>:
    </p>
    <p spaces-before="4">
      {{< file "server/app.js" js >}}
    </p>
    <p spaces-before="0">
      // add after app.get('/video/:id/data', ...) route
    </p>
  </li>
</ol>

<p spaces-before="0">
  app.get('/video/:id', (req, res) => { const path = <code>assets/${req.params.id}.mp4</code>; const stat = fs.statSync(path); const fileSize = stat.size; const range = req.headers.range; if (range) { const parts = range.replace(/bytes=/, "").split("-"); const start = parseInt(parts[0], 10); const end = parts[1] ? parseInt(parts[1], 10) : fileSize-1; const chunksize = (end-start) + 1; const file = fs.createReadStream(path, {start, end}); const head = { 'Content-Range': <code>bytes ${start}-${end}/${fileSize}</code>, 'Accept-Ranges': 'bytes', 'Content-Length': chunksize, 'Content-Type': 'video/mp4', }; res.writeHead(206, head); file.pipe(res); } else { const head = { 'Content-Length': fileSize, 'Content-Type': 'video/mp4', }; res.writeHead(200, head); fs.createReadStream(path).pipe(res); } });
</p>

<p spaces-before="0">
  {{< /file >}}
</p>

<ol start="1">
  <li>
    <p spaces-before="0">
      Save the file, which should automatically restart the server. Then navigate to your browser and refresh the application. You should see something like this:
    </p>
    <p spaces-before="4">
      <img src="Image4.png" alt="React Video streaming app" title="React application Preview" />
    </p>
  </li>
</ol>

<h4 spaces-before="0">
  Inspecting the Streaming Video Route
</h4>

<p spaces-before="0">
  The new <code>/videos/:id</code> route contains a fair bit of code, so let’s walk through it:
</p>

<p spaces-before="0">
  {{< highlight js >}}
</p>

<p spaces-before="0">
  const path = <code>assets/${req.params.id}.mp4</code>; const stat = fs.statSync(path); const fileSize = stat.size; const range = req.headers.range;
</p>

<p spaces-before="0">
  {{< /highlight >}}
</p>

<p spaces-before="0">
  First, we get the <code>id</code> from the route <code>/video/:id</code> and use it to generate the <code>path</code> to the video. Using <code>fs</code>, we read the file to get the file size. For videos, a user's browser will send a <code>range</code> parameter in the request. This lets the server know which chunk of the video to send back to the client.
</p>

<p spaces-before="0">
  Some browsers send a range in the initial request, but others don’t. For those that don’t, or if for any other reason the browser doesn’t send a range, we handle that in the <code>else</code> block. This code gets the file size and send the first few chunks of the video:
</p>

<p spaces-before="0">
  {{< highlight js >}}
</p>

<p spaces-before="0">
  else { const head = { 'Content-Length': fileSize, 'Content-Type': 'video/mp4', }; res.writeHead(200, head); fs.createReadStream(path).pipe(res); }
</p>

<p spaces-before="0">
  {{< / highlight >}}
</p>

<p spaces-before="0">
  Subsequent requests will include a range, which we handle in the <code>if</code> block:
</p>

<p spaces-before="0">
  {{< highlight js >}}
</p>

<p spaces-before="0">
  if (range) { const parts = range.replace(/bytes=/, "").split("-"); const start = parseInt(parts[0], 10); const end = parts[1] ? parseInt(parts[1], 10) : fileSize-1; const chunksize = (end-start) + 1; const file = fs.createReadStream(path, {start, end}); const head = { 'Content-Range': <code>bytes ${start}-${end}/${fileSize}</code>, 'Accept-Ranges': 'bytes', 'Content-Length': chunksize, 'Content-Type': 'video/mp4', }; res.writeHead(206, head); file.pipe(res); }
</p>

<p spaces-before="0">
  {{< / highlight >}}
</p>

<p spaces-before="0">
  This code creates a read stream using the <code>start</code> and <code>end</code> values of the range. We then set the response headers, setting the <code>Content-Length</code> to the chunk size that is calculated from the <code>start</code> and <code>end</code> values. We also use <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/206">HTTP code 206</a>, which signifies that the response contains partial content. This means the browser will keep making requests until it has fetched all chunks of the video.
</p>

<h3 spaces-before="0">
  Dynamically Generate a Thumbnail for a Video
</h3>

<p spaces-before="0">
  Our <code>Home</code> view appears broken at the moment because the poster images are not generated. To generate the thumbnails for these posters:
</p>

<ol start="1">
  <li>
    <p spaces-before="0">
      If you have not yet installed FFmpeg on your system, <a href="https://www.ffmpeg.org/download.html">install it now</a>.
    </p>
  </li>
  
  <li>
    <p spaces-before="0">
      Then, open your terminal in the <code>server</code> directory and install the <code>thumbsupply</code> module, which will use FFmpeg:
    </p>
  </li>
</ol>

<ul>
  <li>
    <p spaces-before="0">
      When using yarn:
    </p>
    <pre><code>  yarn add thumbsupply
</code></pre>
  </li>
  <li>
    <p spaces-before="0">
      When using npm:
    </p>
    <pre><code>  npm install --save thumbsupply
</code></pre>
  </li>
</ul>

<ol start="1">
  <li>
    <p spaces-before="0">
      Add this line after your other <code>require()</code> statements in <code>server/app.js</code>. This will import <code>thumbsupply</code>:
    </p>
    <p spaces-before="4">
      {{< file "server/app.js" js >}}
    </p>
    <p spaces-before="0">
      // add after other require() statements
    </p>
  </li>
</ol>

<p spaces-before="0">
  const thumbsupply = require('thumbsupply');
</p>

<p spaces-before="0">
  {{< /file >}}
</p>

<ol start="1">
  <li>
    <p spaces-before="0">
      Create a new route that will handle generating thumbnails. Add this code after the other routes in <code>server/app.js</code>:
    </p>
    <p spaces-before="4">
      {{< file "server/app.js" js >}}
    </p>
    <p spaces-before="0">
      // add after app.get('/video/:id', ...) route
    </p>
  </li>
</ol>

<p spaces-before="0">
  app.get('/video/:id/poster', (req, res) => { thumbsupply.generateThumbnail(<code>assets/${req.params.id}.mp4</code>) .then(thumb => res.sendFile(thumb)); });
</p>

<p spaces-before="0">
  {{< / highlight >}}
</p>

<pre><code>`thumbsupply` provides a `generateThumbnail` method that accepts a path to a video and then generates the thumbnail. If successful, we send the generated file back to the client.
</code></pre>

<ol start="1">
  <li>
    <p spaces-before="0">
      Save the file, which restarts the server. Refresh the application in the browser, and you should see that the <code>Home</code> view now includes poster images for the videos:
    </p>
    <p spaces-before="4">
      <img src="Image5.png" alt="React Video streaming app" title="React application with poster Images" />
    </p>
  </li>
</ol>

<h2 spaces-before="0">
  Add Captions to Videos
</h2>

<p spaces-before="0">
  Adding captions helps the deaf and hard of hearing to be able to follow along with videos. It’s also fair to point out that <a href="http://web.archive.org/web/20160117160743/http://screenfont.ca/learn/">captions and subtitles are not the same thing</a>. Even though they are not the same, they are implemented the same way.
</p>

<h3 spaces-before="0">
  Create the Caption File
</h3>

<p spaces-before="0">
  A caption file contains the caption text for a video. We won’t look at how to create caption files in this tutorial, but here’s what one looks like:
</p>

<p spaces-before="0">
  {{< file "" >}}
</p>

<p spaces-before="0">
  WEBVTT
</p>

<p spaces-before="0">
  00:00:00.500 --> 00:00:02.000 The Web is always changing
</p>

<p spaces-before="0">
  00:00:02.500 --> 00:00:08.300 and the way we access it is changing
</p>

<p spaces-before="0">
  {{< /file >}}
</p>

<p spaces-before="0">
  The file starts with <code>WEBVTT</code>, which indicates this is a <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebVTT_API">Web Video Track File</a>. This is the format used for captions/subtitles on the web, and its file extension is <code>.vtt</code>. A duration is specified for each caption and the caption text sits under the duration.
</p>

<ol start="1">
  <li>
    <p spaces-before="0">
      Inside the <code>server</code> project, create a <code>captions/</code> directory under <code>assets/</code> directory:
    </p>
    <pre><code> mkdir captions/assets
</code></pre>
  </li>
  
  <li>
    <p spaces-before="0">
      Create a new file named <code>sample.vtt</code> inside the new directory with this snippet:
    </p>
    <p spaces-before="4">
      {{< file "server/assets/captions/sample.vtt" >}}
    </p>
    <p spaces-before="0">
      WEBVTT
    </p>
  </li>
</ol>

<p spaces-before="0">
  00:00:00.500 --> 00:00:02.000 The Web is always changing
</p>

<p spaces-before="0">
  00:00:02.500 --> 00:00:08.300 and the way we access it is changing
</p>

<p spaces-before="0">
  {{< /file >}}
</p>

<pre><code>For this guide's example, the same caption file will be used for all caption requests. In a real application, there would be a unique caption file for each video.
</code></pre>

<h3 spaces-before="0">
  Add the Track Element to Player.js
</h3>

<p spaces-before="0">
  The <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/track"><code>track</code> element</a> is used to support timed text tracks. Update the <code>video</code> element in <code>client/src/Player.js</code> like so:
</p>

<p spaces-before="0">
  {{< file "client/src/Player.js" html >}}
<video controls muted autoPlay crossOrigin="anonymous">
    <source src={`http://localhost:4000/video/${this.state.videoId}`} type="video/mp4"></source>
    <track label="English" kind="captions" srcLang="en" src={`http://localhost:4000/video/${this.state.videoId}/caption`} default></track>
</video>
{{< /file >}}
</p>

<p spaces-before="0">
  We’ve added <code>crossOrigin="anonymous"</code> to the video element; otherwise, the request for captions will fail. The <code>track</code> element includes these attributes:
</p>

<table spaces-before="0" line-breaks-before="2">
  <tr>
    <th>
      Attribute
    </th>
    
    <th>
      Description
    </th>
  </tr>
  
  <tr>
    <td>
      <code>label</code>
    </td>
    
    <td>
      Specifies the label that appears in the captions menu
    </td>
  </tr>
  
  <tr>
    <td>
      <code>kind</code>
    </td>
    
    <td>
      Can be <em x-id="3">captions</em> or <em x-id="3">subtitles</em>
    </td>
  </tr>
  
  <tr>
    <td>
      <code>srcLang</code>
    </td>
    
    <td>
      The language the caption is in (e.g. <code>en</code> means English)
    </td>
  </tr>
  
  <tr>
    <td>
      <code>src</code>
    </td>
    
    <td>
      The location of the caption file
    </td>
  </tr>
  
  <tr>
    <td>
      <code>default</code>
    </td>
    
    <td>
      Indicates this as the default caption
    </td>
  </tr>
</table>

<h3 spaces-before="0">
  Add the Caption Route
</h3>

<p spaces-before="0">
  With the <code>track</code> element set up, we can now create the endpoint that will handle caption requests.
</p>

<ol start="1">
  <li>
    <p spaces-before="0">
      Create a new route in <code>server/app.js</code> after the previous routes:
    </p>
    <p spaces-before="4">
      {{< file "server/app.js" js >}}
    </p>
    <p spaces-before="0">
      // add after the app.get('/video/:id/poster', ...) route
    </p>
  </li>
</ol>

<p spaces-before="0">
  app.get('/video/:id/caption', (req, res) => res.sendFile('assets/captions/sample.vtt', { root: __dirname }));
</p>

<p spaces-before="0">
  {{< /file >}}
</p>

<pre><code>This route will serve the same caption file, regardless of which `id` is passed as a parameter. In a more complete application, you could serve different caption files for different `id`s.
</code></pre>

<ol start="1">
  <li>
    <p spaces-before="0">
      Save the file, which restarts the server. You should now see captions appear on the video:
    </p>
    <p spaces-before="4">
      <img src="Image6.png" alt="React Video streaming app" title="React application with Video Captions" />
    </p>
  </li>
</ol>

<h2 spaces-before="0">
  Making Things Pretty
</h2>

<p spaces-before="0">
  We can add some styles to make the application look better:
</p>

<ol start="1">
  <li>
    <p spaces-before="0">
      Update the React application <code>src/App.css</code> file in your <code>client</code> project with this snippet:
    </p>
    <p spaces-before="4">
      {{< file "client/src/App.css" css >}}
    </p>
    <p spaces-before="0">
      .App-header { min-height: 100vh; color: white; } header, footer { background-color: #374153; text-align: center; color: white; padding: 10px 0; } header { margin-bottom: 50px; font-size: 28px; } footer { margin-top: 50px; font-size: 14px; } .card { margin: 10px 0; } a, a:hover { color: #282c34; text-decoration: none; } video { width: 100%; height: 50vh; } img { height: 200px; object-fit: cover; object-position: center top; } p { margin-bottom: 5px; font-size: 16px; }
    </p>
    <p spaces-before="0">
      {{< /file >}}
    </p>
  </li>
  
  <li>
    <p spaces-before="0">
      Replace <code>src/index.css</code> with:
    </p>
    <p spaces-before="4">
      {{< file "client/src/index.css" css >}}
    </p>
    <p spaces-before="0">
      body { margin: 0; font-family: 'Poppins', sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; background-color: #282c34; }
    </p>
    <p spaces-before="0">
      {{< /file >}}
    </p>
  </li>
  
  <li>
    <p spaces-before="0">
      Add this line to the <code>head</code> section of <code>client/public/index.html</code> in your <code>client</code> project:
    </p>
    <p spaces-before="4">
      {{< file "client/public/index.html" html >}}
    </p>
    <p spaces-before="0">
      <link href="https://fonts.googleapis.com/css?family=Poppins&display=swap" rel="stylesheet" />
    </p>
    <p spaces-before="0">
      {{< /file >}}
    </p>
  </li>
  
  <li>
    <p spaces-before="0">
      Create <code>Header</code> and <code>Footer</code> components in the <code>src/</code> directory of your <code>client</code> project:
    </p>
    <p spaces-before="4">
      {{< file "client/src/Header.js" js >}} import React from 'react'; function Header() { return ( <header> uTunnel </header> ); } export default Header;
{{< /file >}}
    </p>
    <p spaces-before="4">
      {{< file "client/src/Footer.js" js >}} import React from 'react'; function Footer() { return ( <footer> &copy; 2020, uTunnel. All rights reserved. </footer> ); } export default Footer;
{{< /file >}}
    </p>
  </li>
  
  <li>
    <p spaces-before="0">
      Import and use the new <code>Header</code> and <code>Footer</code> components in <code>src/Home.js</code> and <code>src/Player.js</code>. To do this, add these <code>import</code> statements below the other <code>import</code> statements at the top of both files:
    </p>
    <p spaces-before="4">
      {{< file "" js >}}
    </p>
    <p spaces-before="0">
      // add below the other import statements
    </p>
  </li>
</ol>

<p spaces-before="0">
  import Header from './Header'; import Footer from './Footer';
</p>

<p spaces-before="0">
  {{< /file >}}
</p>

<pre><code>Then, add the components to markup in the `return()` method of both files in the following locations:

{{&lt; file "Home.js" html &gt;}}
</code></pre>

<p spaces-before="0">
  // ...
</p>

<p spaces-before="0">
  render() { return (
        <div className="App App-header">
            <Header /><!-- Other component markup --><Footer />
        </div>
    ) }
</p>

<p spaces-before="0">
  // ...
</p>

<p spaces-before="0">
  {{< /file >}}
</p>

<pre><code>{{&lt; file "Player.js" html &gt;}}
</code></pre>

<p spaces-before="0">
  // ...
</p>

<p spaces-before="0">
  render() { return (
        <div className="App">
            <Header />
            <!-- Other component markup -->
            <Footer />
        </div>
    ) }
</p>

<p spaces-before="0">
  // ...
</p>

<p spaces-before="0">
  {{< /file >}}
</p>

<ol start="1">
  <li>
    <p spaces-before="0">
      The application should now look like this:
    </p>
    <p spaces-before="4">
      <img src="Image7.png" alt="React Video streaming app" title="React Video streaming app final preview 1" />
    </p>
    <p spaces-before="4">
      <img src="Image8.png" alt="React Video streaming app" title="React Video streaming app final preview 2" />
    </p>
  </li>
</ol>

<h2 spaces-before="0">
  Conclusion
</h2>

<p spaces-before="0">
  In this tutorial, we have seen how to create a server in Node.js that streams videos, generates captions and posters for those videos, and serves metadata of the videos. We’ve also seen how to use React on the frontend to consume the endpoints and the data generated by the server.
</p>
